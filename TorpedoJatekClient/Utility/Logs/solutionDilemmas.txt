Jelenleg 3 fõ rendering call van + 1 a default FBO quadra:
1.PlayTile-okba beírja az indexeket alpha-ba. Ebbõl Mousemove-nál kiolvassuk mire mutatunk. Utána Töröljük.
2.Kirajzolunk mindent, PlayTileok kicsinyítve, alap transparency értéket kapnak alphaba. Stencil bufferbe mentünk.
3.Kirajzoljuk PlayTileokat stencil buffert használva, tile_state színnel.

TCP OR UDP?
These functions are used to work with TCP Sockets. TCP is used with a full connection, 
whereas UDP is connectionless. TCP also ensures that all packets reach the destionation (when possible). 
TCP also ensures that packets are received in the same order as sent.
UDP:https://www.libsdl.org/projects/SDL_net/docs/SDL_net_25.html#SEC25

Saját pair osztály std::pair-bõl örökölve?
operator<< overloading?

Capture the cursor in beta!
SeaTile and Ground generation with geometry shader?
Partition the scene on CPU side,and only draw SeaTiles and Ground that are visible?

std:algorithm-eket használni?
Time measureing with chrono?
Try-catch exception handling with stack unwinding?
Move-asignments?
std::cin-el kapcsolatos dolgok learnCpp jegyzetben.
SDL_GetTicks64() hogy tovább futhasson?

3D positional audio legyen-e egyáltalán vagy marad a distance? OpenAL esetleg?

Coding conventions:
-Function armunents: function(name_name)
-Pointers: int* name
-References: int& name
-Member names: nameName
-Vertexbuffer: vb_nameName - Ne legyen heapen(jól fel van építve containerekkel)
-Shaderprog: sh_nameName - Ne legyen heapen
-In Getter:Primitive return type = const int getFgv() / User defined return type = const T& getFgv()

Heapen lévõ adatra mutató dereferált pointert adok át függvényeknek referenciaként.
Így csak függvény hívásnál kell dereferálni, lehet használni a "." operátort,
viszont csak a függvény hívás elõtt lehet checkelni, hogy nullptr-e.

Mountain a Frontend kiinduló gyökere. Static változóktól megszabadulni??

x86-os buildelésnél memory limit van.

Polygon draw mode:
glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);