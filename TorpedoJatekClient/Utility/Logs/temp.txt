TextHandler.cpp Blended 32bites
-----------------------------------------------
GLuint TextHandler::RenderTextBlended(const char* text)
{
	SDL_Color col = SDL_Color();
	col.r = 255;
	col.g = 255;
	col.b = 255;
	col.a = 0;
	
	if (!(textSurface = TTF_RenderUTF8_Blended(comicSans, text, col))) {
		std::cout << "[RenderText_Blended] TTF Rendered text is NULL: " << SDL_GetError() << std::endl;
	}
	
	//std::cout << "texturesize " << textSurface->w << " " << textSurface->h << std::endl;
	//std::cout << "textsurfaceformat " << SDL_GetPixelFormatName(textSurface->format->format) << " " << +textSurface->format->BitsPerPixel << " " << +textSurface->format->BytesPerPixel << std::endl;
	
	glGenTextures(1, &textTexture);
	
	glBindTexture(GL_TEXTURE_2D, textTexture);
	
	SDL_PixelFormat* pixelFormat = SDL_AllocFormat(SDL_PIXELFORMAT_RGBA8888);
	SDL_Surface* convertedSurface = SDL_ConvertSurface(textSurface, pixelFormat, 0);
	
	//std::cout << "convertedSurface " << SDL_GetPixelFormatName(convertedSurface->format->format) << " " << +convertedSurface->format->BitsPerPixel << " " << +convertedSurface->format->BytesPerPixel << std::endl;
	
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, convertedSurface->w, convertedSurface->h, 0, GL_RGBA, GL_UNSIGNED_BYTE, convertedSurface->pixels);
	
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);
	
	glBindTexture(GL_TEXTURE_2D, 0);

	return textTexture;
}

Sea.cpp Régi 100*100 mezõs megoldás
-----------------------------------------------
glm::vec3 seatileResult = glm::vec3(0.0f);
for (int i = 0; i < seaTileCount; ++i) {
	seatile_transX = ((i % seaTileScale) * SeaTile::getScaleXZ() * TorpedoGLOBAL::Scale)
		- (SeaTile::getScaleXZ() * seaTileScale / 2.0f * TorpedoGLOBAL::Scale) + TorpedoGLOBAL::Scale;//Ide ezkell,hogy extra tileok kijöjjenek
	seatile_transZ = ((i / seaTileScale) * SeaTile::getScaleXZ() * TorpedoGLOBAL::Scale)
		- (SeaTile::getScaleXZ() * seaTileScale / 2.0f * TorpedoGLOBAL::Scale);//Itt nemkell,hogy az extra tileokat ki lehessen szedni
	
	seatileResult += glm::vec3(seatile_transX, 0, seatile_transZ);
	
	seaTiles.push_back(new SeaTile(seatileResult));
	
	seatileResult = glm::vec3(0.0f);
}

//Kiszedi a azokat az extra tengermezõket,amik a játékmezõk helyén vannak
void Sea::RemoveExtraSeaTiles()
{
	int initialSize = seaTiles.size();
	//bool foundInMyTiles;
	for (std::vector<SeaTile*>::iterator it = seaTiles.begin(); it != seaTiles.end();++it) 
	{
		//foundInMyTiles = false;
		for (PlayTile pTile : myTiles) {
			if (CompareTileTranslations(*it,pTile)) {
				seaTiles.erase(it);
				--it;
				break;
			}
		}
		//if (foundInMyTiles) {
		//	foundInMyTiles = false;
		//	continue;
		//}
		for (PlayTile pTile : enemyTiles) {
			if (CompareTileTranslations(*it, pTile)) {
				seaTiles.erase(it);
				--it;
				break;
			}
		}
	}
	if (initialSize - 2 * myTiles.size() != seaTiles.size()) {
		std::cout << "[Sea::RemoveExtraSeaTiles]: Extra SeaTiles were not removed correctly! initial: " 
			<< initialSize << " after: " << seaTiles.size() << std::endl;
	}
}

//Két játékmezõ elmozgatását nézi meg hogy float közelítõleg egyenlõ-e
bool Sea::CompareTileTranslations(const SeaTile* s_tile, const PlayTile &p_tile) const
{
	return (round(s_tile->getTranslate().x) == round(p_tile.getTranslate().x)
		&& round(s_tile->getTranslate().z) == round(p_tile.getTranslate().z));
}

gameInstance.cpp 3D Positional audio
-----------------------------------------------
float distX = cam_mainCamera.GetAt().x - playerFleet.getBattleShip().getShipTranslate().x;
float distZ = cam_mainCamera.GetAt().z - playerFleet.getBattleShip().getShipTranslate().z;
glm::vec3 dis = glm::normalize(glm::vec3(distX, 0, distZ));
//glm::vec3 objectUp = glm::cross(glm::vec3(1,0,0), dis);
float angle = glm::dot(glm::vec3(1,0,0), dis);
float acf;

if (cam_mainCamera.GetEye().x < playerFleet.getBattleShip().getShipTranslate().x) {
	if (cam_mainCamera.GetAt().z < 0) {
		acf = (acos(angle) * 180 / 3.14f);
	}
	else {
		acf = 180 + (180 - (acos(angle) * 180 / 3.14f));
	}
}
else {
	if (cam_mainCamera.GetAt().z > 0) {
		acf = (acos(angle) * 180 / 3.14f);
	}
	else {
		acf = 180 + (180 - (acos(angle) * 180 / 3.14f));
	}
}
//HA PÁRHUZAMOSAN NÉZÜNK A HAJÓ LOOKATJE FELÉ AKKOR NEMJO SZERINTEM
//LEHET NEM IS KÉNE A STEREO PANNING?
std::cout << acf << " " << angle << " " << len << " " << ds << std::endl;
Mix_SetPosition(1, acf, ds);

gameInstance.cpp  threadFunction
-----------------------------------------------
//	inputThread = SDL_CreateThread(threadFunction, "inputThread", (void*)this);
//A thread hívja meg ezt a függvényt,hogy lehessen meccs közbe gépelni consoleba
//int GameInstance::threadFunction(void *ptr)
//{
//	if (ptr) {
//		GameInstance* pointr = static_cast<GameInstance *>(ptr);
//		pointr->gameLogic.StartMatch(pointr->sea.getTiles(true), pointr->sea.getTiles(false));
//	}
//	std::cout << "The match is over,input thread stopped." << std::endl;
//	return 1;
//
//}

gameLogic.cpp StartMatch
-----------------------------------------------
//Elkezdi a játékmenetet két játékos között
//void GameLogic::StartMatch(std::vector<PlayTile> &myTiles, std::vector<PlayTile> &enemyTiles)
//{
//	std::cout << "Waiting for server to start the match." << std::endl;
//	clientHandler.GetStartSignal();
//
//	ResponseState processableTileState = ResponseState::START_OF_GAME; //statenel 1-piros 2-sarga 3-kek 4-nyert 5-vesztett
//	if (playerNum == 1) {
//		processableTileState = Shoot();
//		enemyTiles[ConvertCoordToTileIndex(processableTile.getPos())].setState(static_cast<int>(processableTileState));
//	}
//
//	while (processableTileState != ResponseState::WIN_PLAYER_ONE && processableTileState != ResponseState::WIN_PLAYER_TWO) {
//		processableTileState = GetShoot();
//		myTiles[ConvertCoordToTileIndex(processableTile.getPos())].setState(static_cast<int>(processableTileState));
//		if (processableTileState != ResponseState::WIN_PLAYER_ONE && processableTileState != ResponseState::WIN_PLAYER_TWO) {
//			processableTileState = Shoot();
//			enemyTiles[ConvertCoordToTileIndex(processableTile.getPos())].setState(static_cast<int>(processableTileState));
//		}
//	}
//
//	clientHandler.~ClientHandler();
//
//	if ((processableTileState == ResponseState::WIN_PLAYER_ONE && playerNum == 1) || (processableTileState == ResponseState::WIN_PLAYER_TWO && playerNum == 2)) {
//		std::cout << "You've won the match!" << std::endl;
//	}
//	else if ((processableTileState == ResponseState::WIN_PLAYER_TWO && playerNum == 1) || (processableTileState == ResponseState::WIN_PLAYER_ONE && playerNum == 2)) {
//		std::cout << "You've lost the match!" << std::endl;
//	}
//
//}

//if (!TorpedoGLOBAL::Debug) {
	//	inputThread = SDL_CreateThread(threadFunction, "inputThread", (void*)this);
	//}


//A thread hívja meg ezt a függvényt,hogy lehessen meccs közbe gépelni consoleba
//int GameInstance::threadFunction(void *ptr)
//{
//	if (ptr) {
//		GameInstance* pointr = static_cast<GameInstance *>(ptr);
//		pointr->gameLogic.StartMatch(pointr->sea.getTiles(true), pointr->sea.getTiles(false));
//	}
//	std::cout << "The match is over,input thread stopped." << std::endl;
//	return 1;
//
//}

gameLogic.cpp PlaceShips v2
----------------------------------------------
//Lerakja a mi hajóinkat a pályára
//void GameLogic::PlaceShips()
//{
//
//	
//
//	PlayTile tmpFront;
//	PlayTile tmpBack;
//
//	PlayTile* frontPos;
//	PlayTile* backPos;
//	do {
//
//		backPos = nullptr;
//
//		std::cout << '\n' <<
//			output << '\n'
//			<< "1. - 1tile ships left: " << unplacedShips.at(0) << '\n'
//			<< "2. - 2tile ships left: " << unplacedShips.at(1) << '\n'
//			<< "3. - 3tile ships left: " << unplacedShips.at(2) << '\n'
//			<< "4. - 4tile ships left: " << unplacedShips.at(3) << '\n'
//			<< "0. - Quit game!" << std::endl;
//
//		//std::cin >> choice;
//
//		if (choice > 0 && choice <= 4) {
//			if (unplacedShips.at(choice - 1) > 0) {
//				std::cout << (choice == 1 ? ship1PlaceText : shipFPlaceText) << std::endl;
//				std::cin >> shipFront;
//
//				if (CheckString(shipFront)) {
//					tmpFront = ProcessString(shipFront);
//					if (myFleet->CheckTile(tmpFront)) {
//						frontPos = &myFleet->getTile(tmpFront.getPos());
//						if (choice > 1) {
//							std::array<PlayTile*, 4> freeChoices = myFleet->getFreeBacks(*frontPos, choice - 1);
//							if (std::none_of(freeChoices.cbegin(), freeChoices.cend(), [](PlayTile* ptr) {return ptr; }))
//							{
//								std::cout << "No position available for the back of the ship!" << std::endl;
//								continue;
//							}
//							else {
//								bool foundInputInChoices = false;
//								while (!foundInputInChoices) {
//									std::cout << shipBPlaceText;
//									for (PlayTile* choisz : freeChoices) {
//										if (choisz) {
//											std::cout << ' ' << choisz->getPos().first << choisz->getPos().second;
//										}
//									}
//									std::cout << std::endl;
//									std::cin >> shipBack;
//
//									if (CheckString(shipBack)) {
//										tmpBack = ProcessString(shipBack);
//										backPos = &myFleet->getTile(tmpBack.getPos());
//										for (PlayTile* choisz : freeChoices) {
//											if (choisz && choisz == backPos) {
//												foundInputInChoices = true;
//											}
//										}
//									}
//								}
//							}
//						}
//						myFleet->PlaceShip(frontPos, backPos);
//						--unplacedShips.at(choice - 1);
//					}
//					else {
//						std::cout << "Tile is not empty!" << std::endl;
//					}
//				}
//			}
//			else {
//				std::cout << "You can't place down any more ships of " << choice << " size!" << std::endl;
//			}
//		}
//		else if (choice == 0 && !std::cin.fail()) {
//			clientHandler.quitGame();
//		}
//		else {
//			std::cin.clear();
//			std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
//			std::cout << "You need to choose between 0-4!" << std::endl;
//		}
//
//	} while (std::any_of(unplacedShips.cbegin(), unplacedShips.cend(), [](int i) {return i != 0; }));
//}


gameLogic.cpp PlaceShips
----------------------------------------------
//std::pair<char,int> tmpTile;
//std::string tmpBack[4] = {" "," "," "," "};
////int tmpMiddle[4] = { 0,0,0,0 };
//std::pair<char, int> tmpMiddle[4] = {std::pair<char,int>('0',0),std::pair<char,int>('0',0),
//	std::pair<char,int>('0',0), std::pair<char,int>('0',0) };
//switch (choice) {
//case 1:
//	if (ship3count != 0) {
//		std::cout << shipFPlaceText << std::endl;
//		std::cin >> shipFront;
//
//		if (CheckString(shipFront)) {
//			tmpTile = ProcessString(shipFront);
//
//			if (CheckTile(tmpTile)) {
//
//				if (TileProcessable(std::pair<char,int>(tmpTile.first+1,tmpTile.second)) 
//					&& TileProcessable(std::pair<char, int>(tmpTile.first + 2, tmpTile.second))) {
//					if (CheckTile(std::pair<char, int>(tmpTile.first + 1, tmpTile.second))
//						&& CheckTile(std::pair<char, int>(tmpTile.first + 2, tmpTile.second)))
//						tmpBack[0] = ProcessTile(std::pair<char, int>(tmpTile.first + 2, tmpTile.second));
//						tmpMiddle[0] = std::pair<char, int>(tmpTile.first + 1, tmpTile.second);
//				}
//				if (TileProcessable(std::pair<char, int>(tmpTile.first - 1, tmpTile.second))
//					&& TileProcessable(std::pair<char, int>(tmpTile.first - 2, tmpTile.second))) {
//					if (CheckTile(std::pair<char, int>(tmpTile.first - 1, tmpTile.second))
//						&& CheckTile(std::pair<char, int>(tmpTile.first - 2, tmpTile.second)))
//						tmpBack[1] = ProcessTile(std::pair<char, int>(tmpTile.first - 2, tmpTile.second));
//						tmpMiddle[1] = std::pair<char, int>(tmpTile.first - 1, tmpTile.second);
//				}
//				if (TileProcessable(std::pair<char, int>(tmpTile.first, tmpTile.second+1))
//					&& TileProcessable(std::pair<char, int>(tmpTile.first, tmpTile.second + 2))) {
//					if (CheckTile(std::pair<char, int>(tmpTile.first, tmpTile.second + 1))
//						&& CheckTile(std::pair<char, int>(tmpTile.first, tmpTile.second + 2)))
//						tmpBack[2] = ProcessTile(std::pair<char, int>(tmpTile.first, tmpTile.second + 2));
//						tmpMiddle[2] = std::pair<char, int>(tmpTile.first, tmpTile.second + 1);
//				}
//				if (TileProcessable(std::pair<char, int>(tmpTile.first, tmpTile.second - 1))
//					&& TileProcessable(std::pair<char, int>(tmpTile.first, tmpTile.second - 2))) {
//					if (CheckTile(std::pair<char, int>(tmpTile.first, tmpTile.second - 1))
//						&& CheckTile(std::pair<char, int>(tmpTile.first, tmpTile.second - 2)))
//						tmpBack[3] = ProcessTile(std::pair<char, int>(tmpTile.first, tmpTile.second - 2));
//						tmpMiddle[3] = std::pair<char, int>(tmpTile.first, tmpTile.second - 1);
//				}
//
//				bool arrayHasElem = false;
//				for (int i = 0; i < 4; i++) {
//					if (tmpBack[i] != " " && tmpMiddle[i].first!='0') { arrayHasElem = true; break; }
//				}
//				if (arrayHasElem) {
//					bool tmpFound = false;
//					int midIndex = 0;
//					do {
//						std::cout << shipBPlaceText << tmpBack[0] << tmpBack[1] << tmpBack[2] << tmpBack[3] << std::endl;
//						std::cin >> shipBack;
//
//
//						for (int i = 0; i < 4; i++) {
//							if (shipBack == tmpBack[i]) {
//								tmpFound = true;
//								midIndex = i;
//								break;
//							}
//						}
//					} while (!tmpFound);
//
//					for (int i = 0; i < activeTileCount; i++) {
//						if (activeTiles[i].first == '0') {
//							activeTiles[i] = tmpTile;
//							break;
//						}
//					}
//					tmpTile = ProcessString(shipBack);
//					for (int i = 0; i < activeTileCount; i++) {
//						if (activeTiles[i].first == '0') {
//							activeTiles[i] = tmpTile;
//							break;
//						}
//					}
//					for (int i = 0; i < activeTileCount; i++) {
//						if (activeTiles[i].first == '0') {
//							activeTiles[i] = tmpMiddle[midIndex];
//							break;
//						}
//					}
//					ship3count--;
//					std::cout << "Ship placed!" << std::endl;
//				}
//				else {
//					std::cout << "There aren't any free tiles for the back(middle) of this ship!" << std::endl;
//				}
//				for (int i = 0; i < 4; i++) {
//					tmpBack[i] = " ";
//					tmpMiddle[i] = std::pair<char,int>('0',0);
//				}
//			}
//			else {
//				std::cout << "Tile is not empty!" << std::endl;
//			}
//		}
//	}
//	break;
//case 2:
//	if (ship2count != 0) {
//		std::cout << shipFPlaceText << std::endl;
//		std::cin >> shipFront;
//
//		if (CheckString(shipFront)) {
//			tmpTile = ProcessString(shipFront);
//
//			if (CheckTile(tmpTile)) {
//
//				if (TileProcessable(std::pair<char, int>(tmpTile.first + 1, tmpTile.second))) {
//					if (CheckTile(std::pair<char, int>(tmpTile.first + 1, tmpTile.second)))
//						tmpBack[0] = ProcessTile(std::pair<char, int>(tmpTile.first + 1, tmpTile.second));
//				}
//				if (TileProcessable(std::pair<char, int>(tmpTile.first - 1, tmpTile.second))) {
//					if (CheckTile(std::pair<char, int>(tmpTile.first - 1, tmpTile.second)))
//						tmpBack[1] = ProcessTile(std::pair<char, int>(tmpTile.first - 1, tmpTile.second));
//				}
//				if (TileProcessable(std::pair<char, int>(tmpTile.first, tmpTile.second+1))) {
//					if (CheckTile(std::pair<char, int>(tmpTile.first, tmpTile.second + 1)))
//						tmpBack[2] = ProcessTile(std::pair<char, int>(tmpTile.first, tmpTile.second + 1));
//				}
//				if (TileProcessable(std::pair<char, int>(tmpTile.first, tmpTile.second - 1))) {
//					if (CheckTile(std::pair<char, int>(tmpTile.first, tmpTile.second - 1)))
//						tmpBack[3] = ProcessTile(std::pair<char, int>(tmpTile.first, tmpTile.second - 1));
//				}
//				bool arrayHasElem = false;
//				for (int i = 0; i < 4; i++) {
//					if (tmpBack[i] != " ") { arrayHasElem = true; break; }
//				}
//				if (arrayHasElem) {
//					bool tmpFound = false;
//					do {
//						std::cout << shipBPlaceText << tmpBack[0] << " " << tmpBack[1] << " " << tmpBack[2] << " " << tmpBack[3] << std::endl;
//						std::cin >> shipBack;
//
//
//						for (int i = 0; i < 4; i++) {
//							if (shipBack == tmpBack[i]) {
//								tmpFound = true;
//								break;
//							}
//						}
//					} while (!tmpFound);
//
//					for (int i = 0; i < activeTileCount; i++) {
//						if (activeTiles[i].first == '0') {
//							activeTiles[i] = tmpTile;
//							break;
//						}
//					}
//					tmpTile = ProcessString(shipBack);
//					for (int i = 0; i < activeTileCount; i++) {
//						if (activeTiles[i].first == '0') {
//							activeTiles[i] = tmpTile;
//							break;
//						}
//					}
//					ship2count--;
//					std::cout << "Ship placed!" << std::endl;
//				}
//				else {
//					std::cout << "There aren't any free tiles for the back of this ship!" << std::endl;
//				}
//				tmpBack[0] = " ";
//				tmpBack[1] = " ";
//				tmpBack[2] = " ";
//				tmpBack[3] = " ";
//			}
//			else {
//				std::cout << "Tile is not empty!" << std::endl;
//			}
//		}
//	}
//	break;
//case 3:
//	if (ship1count != 0) {
//		std::cout << ship1PlaceText << std::endl;
//		std::cin >> shipFront;
//
//		shipBack = shipFront;
//
//		if (CheckString(shipFront)) {
//			tmpTile = ProcessString(shipFront);
//			if (CheckTile(tmpTile)) {
//				for (int i = 0; i < activeTileCount; i++) {
//					if (activeTiles[i].first == '0') {
//						activeTiles[i] = tmpTile;
//						break;
//					}
//				}
//				ship1count--;
//				std::cout << "Ship placed!" << std::endl;
//			}
//			else {
//				std::cout << "Tile is not empty!" << std::endl;
//			}
//		}
//	}
//	break;
//default:
//	std::cout << "You need to choose between 1-3!" << std::endl;
//	break;
//}

fleet.cpp
-----------------------------------
//void Fleet::Init(std::pair<char,int>* actPlayTiles)
//{
//	float tile_transX = 0;
//	float tile_transZ = 0;
//	glm::vec3 tileResult = glm::vec3(0.0f);
//	for (int i = 0; i < 16; i++) {
//
//		tile_transX = (actPlayTiles[i].second - 1) * 2.0f * TorpedoGLOBAL::Scale;
//		tile_transZ = ((actPlayTiles[i].first - 'a') * 2.0f * TorpedoGLOBAL::Scale) - (3.0f*2.0f* TorpedoGLOBAL::Scale);
//
//		tileResult += glm::vec3(mountaincenter_border_Xoffset, 0, 0) +
//			glm::vec3(mountain_tile_offset, 0, 0) +
//			glm::vec3(tile_transX, 0, tile_transZ);
//
//		myShips[i] = Ship(glm::vec3(-1, 1, 1)*tileResult);
//		//enemyShips[i] = Ship(tileResult);
//
//		//enemyShips[i].Init();
//		//myShips[i].Init();
//		tileResult = glm::vec3(0.0f);
//	}
//
//	glm::vec3 battleShipOffset = glm::vec3(firstTile_battleShipOffset, 0, 0) + glm::vec3(mountaincenter_border_Xoffset + mountain_tile_offset, 0, 0);
//	myBattleShip = Ship(-battleShipOffset);
//	//myBattleShip.Init();
//	enemyBattleShip = Ship(battleShipOffset);
//
//	myBattleShip.Init(false);
//	enemyBattleShip.Init(true);
//	for (int i = 0; i < 16; i++) {
//		myShips[i].Init(false);
//		//enemyShips[i].Init(true);
//	}
//}

sea.cpp
-----------------------------------
//void Sea::Init()
//{
//	float tile_transX = 0;
//	float tile_transZ = 0;
//	glm::vec3 tileResult = glm::vec3(0.0f);
//	for (int i = 0; i < mapSize; i++) {
//		tile_transX = (i % TorpedoGLOBAL::MapSize) * 2.0f * TorpedoGLOBAL::Scale;
//		tile_transZ = ((i / TorpedoGLOBAL::MapSize) * 2.0f * TorpedoGLOBAL::Scale) - (3.0f*2.0f * TorpedoGLOBAL::Scale);
//
//		tileResult += glm::vec3(mountaincenter_border_Xoffset, 0, 0) +
//			glm::vec3(mountain_tile_offset, 0, 0) +
//			glm::vec3(tile_transX, 0, tile_transZ);
//
//		enemyPlayTiles[i] = PlayTile(tileResult);
//		myPlayTiles[i] = PlayTile(glm::vec3(-1, 1, 1)*tileResult);
//
//		enemyPlayTiles[i].Init();
//		myPlayTiles[i].Init();
//		tileResult = glm::vec3(0.0f);
//	}
//}

gameinstance.h
------------------------------------

// gömb parametrikus leírása
	glm::vec3 GetUV(float u, float v);

	// a rajzoló metódusaink
	void DrawGround();
	void DrawCone(); // a csonkakúpnak külön van palástja...
	void DrawConeTop(); // ...és teteje
	void DrawSuzanne();
	void DrawEarth();
	void DrawSun(glm::vec3 light_pos); // a "napot" mindig máshova rajzoljuk; a paraméter a pozíció

									   // Textúra erõforrás azonosítók
	GLuint m_coneTextureID;
	GLuint m_coneNormalMapID;
	GLuint m_groundTextureID;
	GLuint m_groundNormalMapID;
	GLuint m_topTextureID;
	GLuint m_topNormalMapID;
	GLuint m_suzanneTextureID;
	GLuint m_suzanneNormalMapID;
	GLuint m_earthTextureID;
	GLuint m_earthNormalMapID;




gVertexBuffer	m_vb_ground; // a talaj geometriája
	gVertexBuffer	m_vb_cone; // a csonkakkúp palást geometriája
	gVertexBuffer	m_vb_cone_top; // a csonkakúp tetejét alkotó körlap geometriája
	gVertexBuffer	m_vb_sphere; // egy egységsugarú gömb geometriája

	Mesh			*m_mesh; // Suzanne

	int N = 20; // a gömb felbontása
	int M = 20;

gameinstance.cpp
------------------------------------


// gömb parametrikus leírása: (u,v) -> (x,y,z)
glm::vec3 GameInstance::GetUV(float u, float v) {
	u *= 2 * f_PI;
	v *= f_PI;
	float cu = cosf(u), su = sinf(u), cv = cosf(v), sv = sinf(v);
	return glm::vec3(cu*sv, cv, su*sv);
}












	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// TALAJ
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

								// attribútumok
	m_vb_ground.AddAttribute(0, 3);
	m_vb_ground.AddAttribute(1, 3);
	m_vb_ground.AddAttribute(2, 2);

	// a 0. attribútum (pozíciók)
	m_vb_ground.AddData(0, -10, 0, -10);
	m_vb_ground.AddData(0, 10, 0, -10);
	m_vb_ground.AddData(0, -10, 0, 10);
	m_vb_ground.AddData(0, 10, 0, 10);

	// az 1. attribútum (normálvektorok)
	m_vb_ground.AddData(1, 0, 1, 0);
	m_vb_ground.AddData(1, 0, 1, 0);
	m_vb_ground.AddData(1, 0, 1, 0);
	m_vb_ground.AddData(1, 0, 1, 0);

	// a 2. attribútum (textúrakoordináták)
	m_vb_ground.AddData(2, 0, 0);
	m_vb_ground.AddData(2, 1, 0);
	m_vb_ground.AddData(2, 0, 1);
	m_vb_ground.AddData(2, 1, 1);

	// Háromszögek indexelése
	m_vb_ground.AddIndex(1, 0, 2);
	m_vb_ground.AddIndex(1, 2, 3);

	// Inicializáljuk a puffereket (VAO, VBO, IB)
	m_vb_ground.InitBuffers();

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// CSONKAKÚP PALÁST
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	// a csonkakúp paraméterei: alsó körvonal sugara, felsö körvonal sugara, magasság
	// a csonkakúp az XZ síkon fog állni
	float r_low = 4;
	float r_high = 2;
	float h = 6;

	m_vb_cone.AddAttribute(0, 3);
	m_vb_cone.AddAttribute(1, 3);
	m_vb_cone.AddAttribute(2, 2);

	// 2*(N+1) vertexet definiálunk egy körív mentén:
	// felváltva rakunk egy vertexet lentre, egyet fentre
	for (int i = 0; i <= N; ++i) {

		float a = i * 2 * f_PI / N; // szög

									// alsó vertexek y = 0 magasságban, r_low sugarú körír mentén,
									// felsõ vertexek y = h magasságban, r_high sugarú körív mentén
									// (a körívek origó középpontúak, XZ síkon fekszenek)
		m_vb_cone.AddData(0, r_low*cosf(a), 0, r_low*sinf(a));
		m_vb_cone.AddData(0, r_high*cosf(a), h, r_high*sinf(a));

		// kiszámoljuk a kúppalástot alkotó vertexek normálisát:
		// középponttól kifele mutatnak (X és Z), de Y irányban enyhén ferdén állnak,
		// a csonkakúp palást ferdeségétõl függõen
		glm::vec3 n = glm::normalize(glm::vec3(cosf(a), (r_low - r_high) / h, sinf(a)));
		m_vb_cone.AddData(1, n.x, n.y, n.z);
		m_vb_cone.AddData(1, n.x, n.y, n.z);

		// a textúrakoordináták: a textúrát sávokra bonta húzzúk rá a palástunkra
		m_vb_cone.AddData(2, 2 * (float)i / N, 1);
		m_vb_cone.AddData(2, 2 * (float)i / N, 0);
	}

	// vertex indexek a háromszögekhez
	// palást = N darab négyzet, egy négyzet = két háromszög
	for (int i = 0; i < N; ++i) {
		m_vb_cone.AddIndex(2 * i, 2 * i + 1, 2 * i + 2);
		m_vb_cone.AddIndex(2 * i + 1, 2 * i + 3, 2 * i + 2);
	}

	m_vb_cone.InitBuffers();

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// CSONKAKÚP TETEJE: KÖRLAP
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	m_vb_cone_top.AddAttribute(0, 3);
	m_vb_cone_top.AddAttribute(1, 3);
	m_vb_cone_top.AddAttribute(2, 2);

	// egy vertex középre, y = h magasságba
	m_vb_cone_top.AddData(0, 0, h, 0);
	m_vb_cone_top.AddData(1, 0, 1, 0);
	m_vb_cone_top.AddData(2, 0.5, 0.5);

	// N+1 vertex a a körvonalon
	for (int i = 0; i <= N; ++i) {

		float a = i * 2 * f_PI / N;
		// y = h magasságban, r_high sugarú körvonal mentén
		m_vb_cone_top.AddData(0, r_high * cosf(a), h, r_high * sinf(a));
		// a normálvektorok minden vextex esetén felfelé mutatnak
		m_vb_cone_top.AddData(1, 0, 1, 0);
		// a textúra közepébõl kivágunk egy 0.5 sugarú körlapot
		m_vb_cone_top.AddData(2, 0.5 * cosf(a) + 0.5, 0.5 * sinf(a) + 0.5);
	}
	// indexek a körlap megalkotásához (N darab háromszög)
	for (int i = 0; i < N; ++i) {
		m_vb_cone_top.AddIndex(0, i + 2, i + 1);
	}

	m_vb_cone_top.InitBuffers();

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// GÖMB
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	m_vb_sphere.AddAttribute(0, 3);
	m_vb_sphere.AddAttribute(1, 3);
	m_vb_sphere.AddAttribute(2, 2);

	// N*M-es rács bejárása, a vertexek (x,y,z) koordinátáját a GetUV függvénnyel kapjuk
	for (int i = 0; i <= N; ++i) {
		for (int j = 0; j <= M; ++j) {
			float u = i / (float)N;
			float v = j / (float)M;
			// pozíció: gömbi koordináták
			m_vb_sphere.AddData(0, GetUV(u, v));
			// szerencsékre gömb esetén ugyanaz a normálvektor:
			// az origóból a gömbfelszín irányába mutató irányvektor
			// de ez csak a gömbnél van így! (Lásd fentebb a csonkakúp palást, ott másképp kellett számolnunk!)
			m_vb_sphere.AddData(1, GetUV(u, v));
			// a textúra-koordináták megyeznek az (u,v) pont koordinátájával
			// (kivéve, hogy a kép rossz irányba állna)
			m_vb_sphere.AddData(2, 1 - u, v);
		}
	}
	// az indexek meghatározása minden négyzethez (N*M négyzetünk van)
	for (int i = 0; i < N; ++i) {
		for (int j = 0; j < M; ++j) {
			// az egyik háromszög a négyzet egyik fele
			m_vb_sphere.AddIndex((i)+(j)*		(N + 1),
				(i)+(j + 1) *	(N + 1),
				(i + 1) + (j) *		(N + 1)
			);
			// a másik háromszög a négyzet másik fele
			m_vb_sphere.AddIndex((i + 1) + (j) *		(N + 1),
				(i)+(j + 1) *	(N + 1),
				(i + 1) + (j + 1) *	(N + 1)
			);
		}
	}

	m_vb_sphere.InitBuffers();
























// talaj kirajzolása
void GameInstance::DrawGround() {

	glm::mat4 matWorld = glm::mat4(1.0f); // nem változtatunk rajta
	glm::mat4 matWorldIT = glm::transpose(glm::inverse(matWorld));
	glm::mat4 mvp = m_camera.GetViewProj() *matWorld;

	m_program.SetUniform("world", matWorld);
	m_program.SetUniform("worldIT", matWorldIT);
	m_program.SetUniform("MVP", mvp);

	m_program.SetTexture("texImage", 0, m_groundTextureID);
	m_program.SetTexture("texNormal", 1, m_groundNormalMapID);

	m_vb_ground.On();
	m_vb_ground.DrawIndexed(GL_TRIANGLES, 0, 6, 0);
	m_vb_ground.Off();

}

// csonkakúp palást kirajzolása
void GameInstance::DrawCone() {

	glm::mat4 matWorld = glm::mat4(1.0f); // nem mozdítjuk el
	glm::mat4 matWorldIT = glm::transpose(glm::inverse(matWorld));
	glm::mat4 mvp = m_camera.GetViewProj() *matWorld;

	m_program.SetUniform("world", matWorld);
	m_program.SetUniform("worldIT", matWorldIT);
	m_program.SetUniform("MVP", mvp);

	m_program.SetTexture("texImage", 0, m_coneTextureID);
	m_program.SetTexture("texNormal", 1, m_coneNormalMapID);

	m_vb_cone.On();
	m_vb_cone.DrawIndexed(GL_TRIANGLES, 0, 2 * 3 * N, 0);
	m_vb_cone.Off();

}

// csonkakúp tetejének kirajzolása
void GameInstance::DrawConeTop() {

	glm::mat4 matWorld = glm::mat4(1.0f); // nem mozdítjuk el
	glm::mat4 matWorldIT = glm::transpose(glm::inverse(matWorld));
	glm::mat4 mvp = m_camera.GetViewProj() *matWorld;

	m_program.SetUniform("world", matWorld);
	m_program.SetUniform("worldIT", matWorldIT);
	m_program.SetUniform("MVP", mvp);

	m_program.SetTexture("texImage", 0, m_topTextureID);
	m_program.SetTexture("texNormal", 1, m_topNormalMapID);

	m_vb_cone_top.On();
	m_vb_cone_top.DrawIndexed(GL_TRIANGLES, 0, 3 * N, 0);
	m_vb_cone_top.Off();

}

void GameInstance::DrawSuzanne() {

	// kétszeresére nagyítjuk és eltoljuk
	glm::mat4 matWorld = glm::translate(glm::vec3(5.0f, 5.0f, 0.0f)) * glm::scale(glm::vec3(2.0f, 2.0f, 2.0f));
	glm::mat4 matWorldIT = glm::transpose(glm::inverse(matWorld));
	glm::mat4 mvp = m_camera.GetViewProj() *matWorld;

	m_program.SetUniform("world", matWorld);
	m_program.SetUniform("worldIT", matWorldIT);
	m_program.SetUniform("MVP", mvp);

	m_program.SetTexture("texImage", 0, m_suzanneTextureID);
	m_program.SetTexture("texNormal", 1, m_suzanneNormalMapID);

	m_mesh->draw();

}

void GameInstance::DrawEarth() {

	// háromszorosára nagyítjuk és eltoljuk
	glm::mat4 matWorld = glm::translate(glm::vec3(-6.0f, 6.0f, 0.0f)) * glm::scale(glm::vec3(3.0f, 3.0f, 3.0f));
	glm::mat4 matWorldIT = glm::transpose(glm::inverse(matWorld));
	glm::mat4 mvp = m_camera.GetViewProj() *matWorld;

	m_program.SetUniform("world", matWorld);
	m_program.SetUniform("worldIT", matWorldIT);
	m_program.SetUniform("MVP", mvp);

	m_program.SetTexture("texImage", 0, m_earthTextureID);
	m_program.SetTexture("texNormal", 1, m_earthNormalMapID);

	m_vb_sphere.On();
	m_vb_sphere.DrawIndexed(GL_TRIANGLES, 0, 2 * 3 * N * M, 0);
	m_vb_sphere.Off();

}

void GameInstance::DrawSun(glm::vec3 light_pos) {

	// a napot jelképezõ gömböt (lekicsinyítve) oda helyezzük, ahol a fényforrásunk is van
	glm::mat4 matWorld = glm::translate<float>(light_pos) * glm::scale(glm::vec3(0.2f, 0.2f, 0.2f));

	glm::mat4 mvp = m_camera.GetViewProj() *matWorld;
	m_program.SetUniform("MVP", mvp);

	m_program.SetUniform("is_sun", true); // értesítjük a shadert, hogy a most kirajzolandó objektum a "nap":
										  // rá ne hasson a megvilágítás, hanem legyen mindig konstans sárga (lásd a fregmens shader kódját)
	m_vb_sphere.On();
	m_vb_sphere.DrawIndexed(GL_TRIANGLES, 0, 2 * 3 * N * M, 0);
	m_vb_sphere.Off();
	m_program.SetUniform("is_sun", false); // ne felejtsük el visszaállítani...

}